<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Buffon's Needle π Approximation</title>
    <link href="./dist/output.css" rel="stylesheet">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/tailwindcss/2.2.19/tailwind.min.css" rel="stylesheet">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Poppins', sans-serif;
            background-color: #0c0a09;
            overflow: hidden;
        }
        .main-container {
            display: flex;
            height: calc(100vh - 65px);
        }
        #left-panel {
            flex-basis: 320px;
            flex-shrink: 0;
            min-width: 250px;
            background: rgba(17, 24, 39, 0.8);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            border-right: 1px solid rgba(255, 255, 255, 0.1);
            overflow-y: auto;
            padding: 1rem;
            display: flex;
            flex-direction: column;
        }
        #resize-handle {
            flex-basis: 6px;
            flex-shrink: 0;
            cursor: col-resize;
            background-color: rgba(55, 65, 81, 0.5);
            transition: background-color 0.2s ease;
        }
        #resize-handle:hover {
            background-color: rgba(30, 144, 255, 0.7);
        }
        #right-panel {
            flex-grow: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            min-width: 0;
            background-color: #0c0a09;
        }
        canvas {
            width: 100%;
            height: 100%;
            background-color: #111827;
        }
        #graph-inset {
            position: absolute;
            top: 20px;
            right: 20px;
            width: 300px;
            height: 200px;
            background: rgba(17, 24, 39, 0.9);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(75, 85, 99, 0.5);
            border-radius: 8px;
            padding: 10px;
            transition: opacity 0.3s ease;
        }
        #graph-inset.hidden {
            opacity: 0;
            pointer-events: none;
        }
        #graph-canvas {
            width: 100%;
            height: 100%;
            border-radius: 4px;
        }
        #left-panel::-webkit-scrollbar { width: 8px; }
        #left-panel::-webkit-scrollbar-track { background: #1f2937; }
        #left-panel::-webkit-scrollbar-thumb { background: #4b5563; border-radius: 4px; }
        #left-panel::-webkit-scrollbar-thumb:hover { background: #6b7280; }
        
        .btn-primary {
            background: linear-gradient(135deg, #3b82f6, #1e40af);
            border: 1px solid rgba(59, 130, 246, 0.3);
            transition: all 0.3s ease;
        }
        .btn-primary:hover {
            background: linear-gradient(135deg, #2563eb, #1d4ed8);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.3);
        }
        .btn-secondary {
            background: rgba(55, 65, 81, 0.5);
            border: 1px solid rgba(75, 85, 99, 0.5);
            transition: all 0.3s ease;
        }
        .btn-secondary:hover {
            background: rgba(75, 85, 99, 0.7);
        }
        
        .stats-card {
            background: rgba(31, 41, 55, 0.6);
            border: 1px solid rgba(75, 85, 99, 0.3);
            backdrop-filter: blur(5px);
        }
    </style>
</head>
<body class="text-gray-200 flex flex-col h-screen">

    <header class="text-center py-4 bg-gray-900/80 border-b border-gray-700/50" style="flex-shrink: 0;">
        <h1 class="text-2xl md:text-3xl text-white">Buffon's Needle π Approximation</h1>
    </header>

    <div class="main-container">
        <div id="left-panel">
            <div>
                <h2 class="text-lg font-semibold text-white mb-3 border-b border-gray-600 pb-2">Controls</h2>
                <div class="space-y-4">
                    <div>
                        <label for="needleLength" class="block text-sm font-medium text-gray-300">Needle Length: <span id="needleLengthValue">0.8</span></label>
                        <input id="needleLength" type="range" min="0.1" max="1.5" step="0.1" value="0.8" class="w-full h-2 bg-gray-700 rounded-lg appearance-none cursor-pointer">
                        <p class="text-xs text-gray-500 mt-1">Relative to line spacing</p>
                    </div>
                    <div>
                        <label for="dropSpeed" class="block text-sm font-medium text-gray-300">Drop Speed: <span id="dropSpeedValue">50</span>/sec</label>
                        <input id="dropSpeed" type="range" min="1" max="200" value="50" class="w-full h-2 bg-gray-700 rounded-lg appearance-none cursor-pointer">
                    </div>
                    <div class="flex space-x-2">
                        <button id="startBtn" class="flex-1 btn-primary text-white px-4 py-2 rounded-lg font-medium">Start</button>
                        <button id="pauseBtn" class="flex-1 btn-secondary text-white px-4 py-2 rounded-lg font-medium" disabled>Pause</button>
                        <button id="resetBtn" class="flex-1 btn-secondary text-white px-4 py-2 rounded-lg font-medium">Reset</button>
                    </div>
                    <div class="mt-3">
                        <label class="flex items-center space-x-2">
                            <input id="showGraph" type="checkbox" checked class="w-4 h-4 text-blue-600 bg-gray-700 border-gray-600 rounded">
                            <span class="text-sm text-gray-300">Show π convergence graph</span>
                        </label>
                    </div>
                </div>
                
                <div class="mt-6 pt-4 border-t border-gray-600">
                    <h3 class="text-md font-semibold text-white mb-3">Statistics</h3>
                    <div class="space-y-3">
                        <div class="stats-card p-3 rounded-lg">
                            <div class="text-xs text-gray-400 uppercase tracking-wide">Total Needles</div>
                            <div id="totalNeedles" class="text-lg font-bold text-white">0</div>
                        </div>
                        <div class="stats-card p-3 rounded-lg">
                            <div class="text-xs text-gray-400 uppercase tracking-wide">Crossing Lines</div>
                            <div id="crossingNeedles" class="text-lg font-bold text-yellow-400">0</div>
                        </div>
                        <div class="stats-card p-3 rounded-lg">
                            <div class="text-xs text-gray-400 uppercase tracking-wide">Estimated π</div>
                            <div id="piEstimate" class="text-xl font-bold text-green-400">--</div>
                        </div>
                        <div class="stats-card p-3 rounded-lg">
                            <div class="text-xs text-gray-400 uppercase tracking-wide">Error</div>
                            <div id="piError" class="text-sm font-medium text-red-400">--</div>
                        </div>
                    </div>
                </div>
                
                <div class="mt-6 pt-4 border-t border-gray-600">
                     <h3 class="text-md font-semibold text-white mb-2">Buffon's Needle</h3>
                     <p id="description" class="text-gray-400 text-sm">
                        This experiment drops needles randomly onto parallel lines. The probability that a needle crosses a line relates to π. Formula: π ≈ 2L/(d × P), where L is needle length, d is line spacing, and P is crossing probability.
                     </p>
                </div>
            </div>
            <footer class="mt-auto pt-4">
                <p class="text-xs text-gray-500 text-center">NitaD, Univ Paris-Saclay, 2025</p>
            </footer>
        </div>

        <div id="resize-handle"></div>

        <div id="right-panel">
            <canvas id="needleCanvas"></canvas>
            <div id="graph-inset">
                <canvas id="graph-canvas" width="280" height="180"></canvas>
            </div>
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            // --- DOM Element References ---
            const canvas = document.getElementById('needleCanvas');
            const ctx = canvas.getContext('2d');
            const leftPanel = document.getElementById('left-panel');
            const rightPanel = document.getElementById('right-panel');
            const resizeHandle = document.getElementById('resize-handle');
            
            const graphInset = document.getElementById('graph-inset');
            const graphCanvas = document.getElementById('graph-canvas');
            const graphCtx = graphCanvas.getContext('2d');
            
            const needleLengthSlider = document.getElementById('needleLength');
            const needleLengthValueSpan = document.getElementById('needleLengthValue');
            const dropSpeedSlider = document.getElementById('dropSpeed');
            const dropSpeedValueSpan = document.getElementById('dropSpeedValue');
            
            const startBtn = document.getElementById('startBtn');
            const pauseBtn = document.getElementById('pauseBtn');
            const resetBtn = document.getElementById('resetBtn');
            const showGraphCheckbox = document.getElementById('showGraph');
            
            const totalNeedlesSpan = document.getElementById('totalNeedles');
            const crossingNeedlesSpan = document.getElementById('crossingNeedles');
            const piEstimateSpan = document.getElementById('piEstimate');
            const piErrorSpan = document.getElementById('piError');

            // --- State Variables ---
            let isResizing = false;
            let isRunning = false;
            let animationId = null;
            
            let needleLength = 0.8;
            let dropSpeed = 50;
            let lineSpacing = 60;
            
            let totalNeedles = 0;
            let crossingNeedles = 0;
            let needles = [];
            let piHistory = []; // Store pi estimates over time
            
            let lastTime = 0;
            let accumulator = 0;

            // --- Event Listeners ---
            needleLengthSlider.addEventListener('input', (e) => {
                needleLength = parseFloat(e.target.value);
                needleLengthValueSpan.textContent = needleLength;
                redraw();
            });
            
            dropSpeedSlider.addEventListener('input', (e) => {
                dropSpeed = parseInt(e.target.value);
                dropSpeedValueSpan.textContent = dropSpeed;
            });
            
            startBtn.addEventListener('click', startExperiment);
            pauseBtn.addEventListener('click', pauseExperiment);
            resetBtn.addEventListener('click', resetExperiment);
            
            showGraphCheckbox.addEventListener('change', (e) => {
                if (e.target.checked) {
                    graphInset.classList.remove('hidden');
                } else {
                    graphInset.classList.add('hidden');
                }
            });

            // Panel resizing
            resizeHandle.addEventListener('mousedown', () => { 
                isResizing = true; 
                document.body.style.cursor = 'col-resize'; 
                document.body.style.userSelect = 'none'; 
            });
            document.addEventListener('mousemove', (e) => { 
                if (isResizing) { 
                    const newWidth = e.clientX; 
                    if (newWidth > 250 && newWidth < window.innerWidth - 250) { 
                        leftPanel.style.flexBasis = `${newWidth}px`; 
                        resizeCanvas(); 
                    } 
                } 
            });
            document.addEventListener('mouseup', () => { 
                isResizing = false; 
                document.body.style.cursor = 'default'; 
                document.body.style.userSelect = ''; 
            });
            window.addEventListener('resize', resizeCanvas);

            function resizeCanvas() {
                canvas.width = rightPanel.clientWidth;
                canvas.height = rightPanel.clientHeight;
                lineSpacing = Math.max(40, Math.min(80, canvas.height / 12));
                redraw();
            }

            function startExperiment() {
                if (!isRunning) {
                    isRunning = true;
                    startBtn.disabled = true;
                    pauseBtn.disabled = false;
                    lastTime = performance.now();
                    animate();
                }
            }

            function pauseExperiment() {
                isRunning = false;
                startBtn.disabled = false;
                pauseBtn.disabled = true;
                if (animationId) {
                    cancelAnimationFrame(animationId);
                }
            }

            function resetExperiment() {
                pauseExperiment();
                totalNeedles = 0;
                crossingNeedles = 0;
                needles = [];
                piHistory = [];
                updateStats();
                redraw();
                drawGraph();
            }

            function animate(currentTime = 0) {
                if (!isRunning) return;

                const deltaTime = currentTime - lastTime;
                lastTime = currentTime;
                accumulator += deltaTime;

                const dropInterval = 1000 / dropSpeed; // ms between drops

                while (accumulator >= dropInterval) {
                    dropNeedle();
                    accumulator -= dropInterval;
                }

                redraw();
                drawGraph();
                animationId = requestAnimationFrame(animate);
            }

            function dropNeedle() {
                // Random position and angle
                const x = Math.random() * canvas.width;
                const y = Math.random() * canvas.height;
                const angle = Math.random() * Math.PI; // 0 to π radians
                
                // Calculate needle endpoints
                const actualLength = needleLength * lineSpacing;
                const halfLength = actualLength / 2;
                const x1 = x - halfLength * Math.cos(angle);
                const y1 = y - halfLength * Math.sin(angle);
                const x2 = x + halfLength * Math.cos(angle);
                const y2 = y + halfLength * Math.sin(angle);
                
                // Check if needle crosses a line
                const lineY1 = Math.floor(y1 / lineSpacing) * lineSpacing;
                const lineY2 = Math.floor(y2 / lineSpacing) * lineSpacing;
                const crosses = lineY1 !== lineY2;
                
                const needle = {
                    x1, y1, x2, y2, crosses, age: 0
                };
                
                needles.push(needle);
                totalNeedles++;
                if (crosses) crossingNeedles++;
                
                // Keep only recent needles for performance
                if (needles.length > 1000) {
                    needles.shift();
                }
                
                updateStats();
            }

            function updateStats() {
                totalNeedlesSpan.textContent = totalNeedles.toLocaleString();
                crossingNeedlesSpan.textContent = crossingNeedles.toLocaleString();
                
                if (crossingNeedles > 0) {
                    const probability = crossingNeedles / totalNeedles;
                    const piEstimation = (2 * needleLength) / probability;
                    const error = Math.abs(piEstimation - Math.PI);
                    const errorPercent = (error / Math.PI) * 100;
                    
                    piEstimateSpan.textContent = piEstimation.toFixed(6);
                    piErrorSpan.textContent = `${error.toFixed(6)} (${errorPercent.toFixed(2)}%)`;
                    
                    // Store pi estimate for graph (every 10 needles to reduce data)
                    if (totalNeedles % 10 === 0 || totalNeedles < 100) {
                        piHistory.push({
                            needles: totalNeedles,
                            pi: piEstimation
                        });
                        
                        // Keep only last 500 points for performance
                        if (piHistory.length > 500) {
                            piHistory.shift();
                        }
                    }
                } else {
                    piEstimateSpan.textContent = '--';
                    piErrorSpan.textContent = '--';
                }
            }

            function redraw() {
                // Clear canvas
                ctx.fillStyle = '#111827';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                drawLines();
                drawNeedles();
            }

            function drawLines() {
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
                ctx.lineWidth = 1;
                
                for (let y = 0; y <= canvas.height; y += lineSpacing) {
                    ctx.beginPath();
                    ctx.moveTo(0, y);
                    ctx.lineTo(canvas.width, y);
                    ctx.stroke();
                }
            }

            function drawNeedles() {
                needles.forEach(needle => {
                    needle.age++;
                    const alpha = Math.max(0.1, 1 - needle.age / 200); // Fade out over time
                    
                    ctx.lineWidth = 2;
                    ctx.strokeStyle = needle.crosses 
                        ? `rgba(255, 255, 0, ${alpha})` 
                        : `rgba(255, 255, 255, ${alpha * 0.6})`;
                    
                    ctx.beginPath();
                    ctx.moveTo(needle.x1, needle.y1);
                    ctx.lineTo(needle.x2, needle.y2);
                    ctx.stroke();
                });
                
                // Remove very old needles
                needles = needles.filter(needle => needle.age < 300);
            }

            function drawGraph() {
                if (!showGraphCheckbox.checked || piHistory.length < 2) return;
                
                const width = graphCanvas.width;
                const height = graphCanvas.height;
                const padding = 30;
                const plotWidth = width - 2 * padding;
                const plotHeight = height - 2 * padding;
                
                // Clear graph
                graphCtx.fillStyle = '#1f2937';
                graphCtx.fillRect(0, 0, width, height);
                
                // Find data ranges
                const minNeedles = Math.min(...piHistory.map(p => p.needles));
                const maxNeedles = Math.max(...piHistory.map(p => p.needles));
                const minPi = Math.min(2.5, ...piHistory.map(p => p.pi));
                const maxPi = Math.max(4, ...piHistory.map(p => p.pi));
                
                // Draw grid lines
                graphCtx.strokeStyle = 'rgba(75, 85, 99, 0.3)';
                graphCtx.lineWidth = 1;
                
                // Horizontal grid lines
                for (let i = 0; i <= 5; i++) {
                    const y = padding + (i / 5) * plotHeight;
                    graphCtx.beginPath();
                    graphCtx.moveTo(padding, y);
                    graphCtx.lineTo(width - padding, y);
                    graphCtx.stroke();
                }
                
                // Vertical grid lines
                for (let i = 0; i <= 5; i++) {
                    const x = padding + (i / 5) * plotWidth;
                    graphCtx.beginPath();
                    graphCtx.moveTo(x, padding);
                    graphCtx.lineTo(x, height - padding);
                    graphCtx.stroke();
                }
                
                // Draw π reference line
                const piY = padding + (1 - (Math.PI - minPi) / (maxPi - minPi)) * plotHeight;
                graphCtx.strokeStyle = 'rgba(34, 197, 94, 0.8)';
                graphCtx.lineWidth = 2;
                graphCtx.setLineDash([5, 5]);
                graphCtx.beginPath();
                graphCtx.moveTo(padding, piY);
                graphCtx.lineTo(width - padding, piY);
                graphCtx.stroke();
                graphCtx.setLineDash([]);
                
                // Draw pi estimate curve
                if (piHistory.length > 1) {
                    graphCtx.strokeStyle = '#60a5fa';
                    graphCtx.lineWidth = 2;
                    graphCtx.beginPath();
                    
                    for (let i = 0; i < piHistory.length; i++) {
                        const point = piHistory[i];
                        const x = padding + ((point.needles - minNeedles) / (maxNeedles - minNeedles)) * plotWidth;
                        const y = padding + (1 - (point.pi - minPi) / (maxPi - minPi)) * plotHeight;
                        
                        if (i === 0) {
                            graphCtx.moveTo(x, y);
                        } else {
                            graphCtx.lineTo(x, y);
                        }
                    }
                    graphCtx.stroke();
                }
                
                // Draw labels
                graphCtx.fillStyle = '#d1d5db';
                graphCtx.font = '10px Poppins';
                graphCtx.textAlign = 'center';
                graphCtx.textBaseline = 'top';
                
                // Y-axis labels
                graphCtx.textAlign = 'right';
                graphCtx.textBaseline = 'middle';
                for (let i = 0; i <= 5; i++) {
                    const y = padding + (i / 5) * plotHeight;
                    const value = maxPi - (i / 5) * (maxPi - minPi);
                    graphCtx.fillText(value.toFixed(1), padding - 5, y);
                }
                
                // X-axis labels
                graphCtx.textAlign = 'center';
                graphCtx.textBaseline = 'top';
                for (let i = 0; i <= 5; i++) {
                    const x = padding + (i / 5) * plotWidth;
                    const value = minNeedles + (i / 5) * (maxNeedles - minNeedles);
                    graphCtx.fillText(value.toFixed(0), x, height - padding + 5);
                }
                
                // Title and axis labels
                graphCtx.fillStyle = '#f9fafb';
                graphCtx.font = '12px Poppins';
                graphCtx.textAlign = 'center';
                graphCtx.textBaseline = 'top';
                graphCtx.fillText('π Convergence', width / 2, 5);
                
                // π reference label
                graphCtx.fillStyle = '#22c55e';
                graphCtx.font = '10px Poppins';
                graphCtx.textAlign = 'left';
                graphCtx.fillText(`π = ${Math.PI.toFixed(6)}`, padding + 5, piY - 15);
            }

            // --- Mouse wheel for needle length adjustment ---
            canvas.addEventListener('wheel', (e) => {
                e.preventDefault();
                
                let currentValue = parseFloat(needleLengthSlider.value);
                const step = 0.1;
                
                if (e.deltaY > 0) {
                    currentValue = Math.max(0.1, currentValue - step);
                } else {
                    currentValue = Math.min(1.5, currentValue + step);
                }
                
                needleLengthSlider.value = currentValue;
                needleLengthSlider.dispatchEvent(new Event('input'));
            }, { passive: false });

            // --- Initial Setup ---
            resizeCanvas();
            drawGraph();
        });
    </script>
</body>
</html>